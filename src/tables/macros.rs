#[macro_export]
/// Generate the indexed table array. Types that are generated by the macro are
/// marked `struct` or `enum` for clarity.
macro_rules! table_array {
    (
        struct $table:ident {
            type Arena = $arena:ident;
            type RowEnum = enum $row_enum:ident;
            type IndexEnum = enum $index_enum:ident;
            tables {
                $(
                    $field:ident: struct $variant:ident {
                        type Row = struct $v_row:ident;
                        fields {
                            $( $v_field:ident: $v_t:ty, )*
                        }
                        links {
                            $( $v_link:ident: $v_a:ty, )*
                        }
                    },
                )*
            }
            transitions {
                $( $t_field:ident: $t_variant:ident, )*
            }
        }
    ) => {
        #[derive(Debug, Default)]
        pub struct $table {
            indices: $crate::IdIndices<$arena, $index_enum>,
            $( pub $field: $variant, )*
            $( $t_field: $t_variant, )*
        }

        #[allow(dead_code)]
        impl $table {
            pub fn insert<I: $crate::ValidId<$arena>, R: Into<$row_enum>>(
                &mut self,
                id: I,
                row: R,
            ) {
                self.insert_inner(id, row.into());
            }

            fn insert_inner<I: $crate::ValidId<$arena>>(&mut self, id: I, row: $row_enum) {
                self.remove(id);
                let indices = &mut self.indices;
                match row {
                    $(
                        $row_enum::$variant(row) => { self.$field.insert(id, row, indices); },
                    )*
                };
            }

            pub fn remove<I: $crate::ValidId<$arena>>(&mut self, id: I) -> Option<$row_enum> {
                let index = self.indices.remove(id)?;

                let row = match index {
                    $(
                        $index_enum::$variant(index) => self.$field.swap_remove(index, &mut self.indices).into(),
                    )*
                };

                Some(row)
            }
        }

        row_enum! { enum $row_enum { $( $variant($v_row), )* } }
        index_enum! { enum $index_enum { $( $variant, )* } }

        $(
            table! {
                struct $variant {
                    type Arena = $arena;
                    type Row = struct $v_row;
                    type Index = $index_enum;
                    fields {
                        $( $v_field: $v_t, )*
                    }
                    links {
                        $( $v_link: $v_a, )*
                    }
                }
            }
        )*
    };
}

#[macro_export]
macro_rules! index_enum {
    (
        enum $name:ident {
            $( $variant:ident, )*
        }
    ) => {
        #[derive(Debug, Eq, PartialEq, Hash)]
        pub enum $name {
            $(
                $variant($crate::Index<$variant>),
            )*
        }

        $(
            impl From<$crate::Index<$variant>> for $name {
                fn from(value: $crate::Index<$variant>) -> Self {
                    Self::$variant(value)
                }
            }
        )*
    }
}

#[macro_export]
macro_rules! row_enum {
    (
        enum $name:ident {
            $( $variant:ident($v_row:ident), )*
        }
    ) => {
        #[derive(Debug)]
        pub enum $name {
            $(
                $variant($v_row),
            )*
        }

        $(
            impl From<$v_row> for $name {
                fn from(value: $v_row) -> Self {
                    Self::$variant(value)
                }
            }
        )*
    }
}

#[macro_export]
macro_rules! table {
    (
        struct $table:ident {
            type Arena = $arena:ident;
            type Row = struct $row:ident;
            type Index = $state_index:ident;
            fields {
                $( $field:ident: $t:ty, )* $(,)?
            }
            links {
                $( $link:ident: $a:ty, )* $(,)?
            }
        }
    ) => {
        #[derive(Debug)]
        pub struct $table {
            pub id: $crate::Column<Self, $crate::Id<$arena>>,
            $(
                pub $field: $crate::Column<Self, $t>,
            )*
            $(
                pub $link: $crate::IdColumn<Self, $a>,
            )*
        }

        impl Default for $table {
            fn default() -> Self {
                Self {
                    id: Default::default(),
                    $(
                        $field: Default::default(),
                    )*
                    $(
                        $link: Default::default(),
                    )*
                }
            }
        }

        #[allow(dead_code)]
        impl $table {
            fn insert<I: $crate::ValidId<$arena>>(
                &mut self,
                id: I,
                row: $row,
                indices: &mut $crate::IdIndices<$arena, $state_index>
            ) {
                let index = self.insert_inner(row);
                indices.insert(id, index);
            }

            fn insert_inner(&mut self, row: $row) -> $crate::Index<Self> {
                $(
                    self.$field.push(row.$field);
                )*
                $(
                    self.$link.push(row.$link.map(Valid::assert));
                )*
                self.id.push(row.id)
            }

            fn swap_remove(
                &mut self,
                index: $crate::Index<Self>,
                indices: &mut $crate::IdIndices<$arena, $state_index>
            ) -> $row {
                let row = self.swap_remove_inner(&index);
                if let Some(swapped) = self.id.get(&index).map($crate::Valid::assert) {
                    indices.insert(swapped, index);
                }
                row
            }

            fn swap_remove_inner(&mut self, index: &$crate::Index<Self>) -> $row {
                $row {
                    id: self.id.swap_remove(index),
                    $(
                        $field: self.$field.swap_remove(index),
                    )*
                    $(
                        $link: self.$link.swap_remove(index),
                    )*
                }
            }

            pub fn indices(&self) -> $crate::Indices<Self> {
                self.id.indices()
            }

            pub fn len(&self) -> usize {
                self.id.len()
            }
        }

        #[derive(Debug)]
        pub struct $row {
            pub id: $crate::Id<$arena>,
            $(
                pub $field: $t,
            )*
            $(
                pub $link: Option<$crate::Id<$a>>,
            )*
        }
    }
}

#[cfg(test)]
#[allow(dead_code)]
mod tests {
    use crate::*;

    #[derive(Debug)]
    pub struct Colony;

    dynamic_arena!(Colony);

    #[derive(Debug)]
    pub struct Freighter;

    fixed_arena!(Freighter);

    #[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
    pub struct Time(f64);

    table_array! {
        struct FreighterState {
            type Arena = Freighter;
            type RowEnum = enum FreighterStateRow;
            type IndexEnum = enum FreighterStateIndex;
            tables {
                idle: struct Idle {
                    type Row = struct IdleRow;
                    fields {
                        arrival: Time,
                    }
                    links {
                        location: Colony,
                    }
                },
                moving: struct Moving {
                    type Row = struct MovingRow;
                    fields {

                    }
                    links {
                        from: Colony,
                        to: Colony,
                    }
                },
            }
            transitions {}
        }
    }

    #[test]
    fn test() {
        let mut a = Allocator::<Freighter>::default();
        let mut colonies = Allocator::<Colony>::default();
        let mut s = FreighterState::default();

        let c = colonies.create().id();
        let id = a.create();
        s.insert(
            id,
            IdleRow {
                id: id.id(),
                arrival: Time(0.0),
                location: Some(c),
            },
        );

        // panic!("{:#?}", s);
    }

    #[derive(Debug, Default)]
    pub struct ArenaA;
    dynamic_arena!(ArenaA);

    #[derive(Debug, Default)]
    pub struct ArenaB;
    dynamic_arena!(ArenaB);

    #[derive(Debug, Default)]
    pub struct ArenaC;
    dynamic_arena!(ArenaC);

    #[derive(Debug, Default)]
    pub struct TableC {
        pub ids: IdColumn<Self, ArenaC>,
        pub value: Column<Self, u32>,
        pub id_a: IdColumn<Self, ArenaA>,
        pub id_b: IdColumn<Self, ArenaB>,
    }

    impl TableC {
        pub fn push<A: ValidId<ArenaA>, B: ValidId<ArenaB>, ID: ValidId<ArenaC>>(
            &mut self,
            row: RowC<ID, A, B>,
        ) -> Index<Self> {
            self.value.push(row.value);
            self.id_a.push(Some(row.id_a));
            self.id_b.push(Some(row.id_b));
            self.ids.push(Some(row.id))
        }

        fn swap_remove<'a>(
            &mut self,
            index: &Index<Self>,
            allocator_a: &'a Allocator<ArenaA>,
            allocator_b: &'a Allocator<ArenaB>,
        ) -> Option<RowC<Valid<'a, Id<ArenaC>>, Valid<'a, Id<ArenaA>>, Valid<'a, Id<ArenaB>>>>
        {
            let id = Valid::assert(self.ids.swap_remove(index).unwrap());
            let value = self.value.swap_remove(index);

            let id_a = self
                .id_a
                .swap_remove(index)
                .and_then(|id| allocator_a.validate(id));

            let id_b = self
                .id_b
                .swap_remove(index)
                .and_then(|id| allocator_b.validate(id));

            Some(RowC {
                id,
                value,
                id_a: id_a?,
                id_b: id_b?,
            })
        }
    }

    pub struct RowC<ID, A, B> {
        id: ID,
        value: u32,
        id_a: A,
        id_b: B,
    }

    #[test]
    fn abc() {}
}
