#[macro_export]
/// Generate the indexed table array. Types that are generated by the macro are
/// marked `struct` or `enum` for clarity.
macro_rules! table_array {
    (
        struct $table:ident {
            type Arena = $arena:ident;
            type RowEnum = enum $row_enum:ident;
            type IndexEnum = enum $index_enum:ident;
            tables {
                $(
                    $field:ident: struct $variant:ident {
                        type Row = struct $v_row:ident;
                        fields {
                            $( $v_field:ident: $v_t:ty, )*
                        }
                        links {
                            $( $v_link:ident: $v_a:ty, )*
                        }
                    },
                )*
            }
            transitions {
                $( $t_field:ident: $t_variant:ident, )*
            }
        }
    ) => {
        #[derive(Debug, Default)]
        pub struct $table {
            indices: $crate::IdIndices<$arena, $index_enum>,
            $( pub $field: $variant, )*
            $( $t_field: $t_variant, )*
        }

        #[allow(dead_code)]
        impl $table {
            pub fn insert<'a, I: ValidId<$arena>, R>(
                &mut self,
                id: I,
                row: Valid<'a, R>,
            )
             where $row_enum: From<R>
            {
                self.insert_inner(id, row.value.into())
            }

            fn insert_inner<I: $crate::ValidId<$arena>>(&mut self, id: I, row: $row_enum) {
                self.remove(id);
                let indices = &mut self.indices;
                match row {
                    $(
                        $row_enum::$variant(row) => self.$field.insert(Valid::assert(row), indices),
                    )*
                };
            }

            pub fn remove<I: $crate::ValidId<$arena>>(&mut self, id: I) -> Option<$row_enum> {
                let index = self.indices.remove(id)?;

                let row = match index {
                    $(
                        $index_enum::$variant(index) => self.$field.swap_remove(index, &mut self.indices).into(),
                    )*
                };

                Some(row)
            }
        }

        row_enum! { enum $row_enum { $( $variant($v_row), )* } }
        index_enum! { enum $index_enum { $( $variant, )* } }

        $(
            table! {
                struct $variant {
                    type Arena = $arena;
                    type Row = struct $v_row;
                    type Index = $index_enum;
                    fields {
                        $( $v_field: $v_t, )*
                    }
                    links {
                        $( $v_link: $v_a, )*
                    }
                }
            }
        )*
    };
}
